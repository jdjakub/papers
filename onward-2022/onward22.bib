@inproceedings{SnS,
author = {Hempel, Brian and Lubin, Justin and Chugh, Ravi},
title = {Sketch-n-Sketch: Output-Directed Programming for SVG},
year = {2019},
isbn = {9781450368162},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3332165.3347925},
doi = {10.1145/3332165.3347925},
abstract = {For creative tasks, programmers face a choice: Use a GUI and sacrifice flexibility, or write code and sacrifice ergonomics?To obtain both flexibility and ease of use, a number of systems have explored a workflow that we call output-directed programming. In this paradigm, direct manipulation of the program's graphical output corresponds to writing code in a general-purpose programming language, and edits not possible with the mouse can still be enacted through ordinary text edits to the program. Such capabilities provide hope for integrating graphical user interfaces into what are currently text-centric programming environments.To further advance this vision, we present a variety of new output-directed techniques that extend the expressive power of Sketch-n-Sketch, an output-directed programming system for creating programs that generate vector graphics. To enable output-directed interaction at more stages of program construction, we expose intermediate execution products for manipulation and we present a mechanism for contextual drawing. Looking forward to output-directed programming beyond vector graphics, we also offer generic refactorings through the GUI, and our techniques employ a domain-agnostic provenance tracing scheme.To demonstrate the improved expressiveness, we implement a dozen new parametric designs in Sketch-n-Sketch without text-based edits. Among these is the first demonstration of building a recursive function in an output-directed programming setting.},
booktitle = {Proceedings of the 32nd Annual ACM Symposium on User Interface Software and Technology},
pages = {281–292},
numpages = {12},
keywords = {svg, sketch-n-sketch, output-directed programming},
location = {New Orleans, LA, USA},
series = {UIST '19}
}
@article{subtext,
author = {Edwards, Jonathan},
title = {Subtext: Uncovering the Simplicity of Programming},
year = {2005},
issue_date = {October 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1103845.1094851},
doi = {10.1145/1103845.1094851},
abstract = {Representing programs as text strings makes programming harder then it has to be. The source text of a program is far removed from its behavior. Bridging this conceptual gulf is what makes programming so inhumanly difficult -- we are not compilers. Subtext is a new medium in which the representation of a program is the same thing as its execution. Like a spreadsheet, a program is visible and alive, constantly executing even as it is edited. Program edits are coherent semantic transformations.The essence of this new medium is copying. Programs are constructed by copying and executed by copy flow: the projection of changes through copies. The simple idea of copying develops into a rich theory of higher-order continual copying of trees. Notably absent are symbolic names, the workhorse of textual notation, replaced by immediately-bound explicit relationships. Subtext unifies traditionally distinct programming tools and concepts, and enables some novel ones. Ancestral structures are a new primitive data type that combines the features of lists and records, along with unproblematic multiple inheritance. Adaptive conditionals use first-class program edits to dynamically adapt behavior.A prototype implementation shows promise, but calls for much further research. Subtext suggests that we can make programming radically easier, if we are willing to be radical.},
journal = {SIGPLAN Not.},
month = oct,
pages = {505–518},
numpages = {14},
keywords = {non-textual programming, copying, prototypes, visual programming}
}
@inproceedings{infra,
author = {Hall, Christopher and Standley, Trevor and Hollerer, Tobias},
title = {Infra: Structure All the Way down: Structured Data as a Visual Programming Language},
year = {2017},
isbn = {9781450355308},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3133850.3133852},
doi = {10.1145/3133850.3133852},
abstract = {We present Infra, a new baseline medium for representing data. With Infra, arbitrarily-complex structured data can be encoded, viewed, edited, and processed, all while remaining in an efficient non-textual form. It is suitable for the full range of information modalities, from free-form input, to compact schema-conforming structures. With its own equivalent of a text editor and text-field widget, Infra is designed to target the domain currently dominated by flat character strings while simultaneously enabling the expression of sub-structure, inter-reference, dynamic dependencies, abstraction, computation, and context (metadata). Existing metaformats fit neatly into two categories. They are either textual for human readability (such as XML and JSON) or binary for compact serialization (such as Thrift and Protocol Buffers). In contrast, Infra unifies those two paradigms. In order to have the desirable properties of binary formats, Infra has no textual representation. And yet, it is designed to be easily read and authored by end-users. We show how the organization Infra brings to data makes a new non-textual programming paradigm viable. Programs that modify data can now be embedded into the data itself. Furthermore, these programs can often be authored by demonstration. We argue that Infra can be used to improve existing software projects and that bringing direct authoring and human readability to a binary data paradigm could have rippling ramifications on the computing landscape.},
booktitle = {Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {180–197},
numpages = {18},
keywords = {metaformat, human-readability, structure editing, end-user development},
location = {Vancouver, BC, Canada},
series = {Onward! 2017}
}
@inproceedings{Webstrates,
author = {Klokmose, Clemens N. and Eagan, James R. and Baader, Siemen and Mackay, Wendy and Beaudouin-Lafon, Michel},
title = {Webstrates: Shareable Dynamic Media},
year = {2015},
isbn = {9781450337793},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2807442.2807446},
doi = {10.1145/2807442.2807446},
abstract = {We revisit Alan Kay's early vision of dynamic media that blurs the distinction between documents and applications. We introduce shareable dynamic media that are malleable by users, who may appropriate them in idiosyncratic ways; shareable among users, who collaborate on multiple aspects of the media; and distributable across diverse devices and platforms. We present Webstrates, an environment for exploring shareable dynamic media. Webstrates augment web technology with real-time sharing. They turn web pages into substrates, i.e. software entities that act as applications or documents depending upon use. We illustrate Webstrates with two implemented case studies: users collaboratively author an article with functionally and visually different editors that they can personalize and extend at run-time; and they orchestrate its presentation and audience participation with multiple devices. We demonstrate the simplicity and generative power of Webstrates with three additional prototypes and evaluate it from a systems perspective.},
booktitle = {Proceedings of the 28th Annual ACM Symposium on User Interface Software \& Technology},
pages = {280–290},
numpages = {11},
keywords = {web, real-time collaborative documents, dynamic media},
location = {Charlotte, NC, USA},
series = {UIST '15}
}
@online{COLAs,
  title = "Accessible Language-Based Environments of Recursive Theories",
  url = "http://www.vpri.org/pdf/rn2006001a_colaswp.pdf",
  author = "Ian Piumarta",
  year = "2006",
}
@online{OROM,
  title = "Open, Reusable Object Models",
  url = "http://www.vpri.org/pdf/tr2006003a_objmod.pdf",
  author = "Ian Piumarta and Alessandro Warth",
  year = "2006",
}
@online{dadgum66,
  title = "Living Inside Your Own Black Box",
  url = "https://prog21.dadgum.com/66.html",
  author = "James Hague",
  year = "2010",
}
@proceedings{SSS08,
title = {S3 '08: Workshop on Self-Sustaining Systems},
year = {2008},
isbn = {9783540892755},
editor = {Robert Hirschfeld and Kim Rose},
publisher = {Springer},
abstract = {
S3 is a forum for discussion of topics relating to computer systems and languages that are able to bootstrap, implement, modify, and maintain themselves. One property of these systems is that their implementation is based on small but powerful abstractions; examples include (amongst others) Squeak/Smalltalk, COLA, Klein/Self, PyPy/Python, Rubinius/Ruby, and Lisp. Such systems are the engines of their own replacement, giving researchers and developers great power to experiment with, and explore future directions from within their own small language kernels.
},
location = {Potsdam, Germany},
url = {https://doi.org/10.1007/978-3-540-89275-5},
doi = {10.1007/978-3-540-89275-5}
}
@proceedings{SSS10,
title = {S3 '10: Workshop on Self-Sustaining Systems},
year = {2010},
isbn = {9781450304917},
editor = {Robert Hirschfeld and Hidehiko Masuhara and Kim Rose},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
abstract = {The Workshop on Self-sustaining Systems (S3) is a forum for discussion of topics relating to computer systems and languages that are able to bootstrap, implement, modify, and maintain themselves. One property of these systems is that their implementation is based on small but powerful abstractions; examples include (amongst others) Squeak/Smalltalk, COLA, Klein/Self, PyPy/Python, Rubinius/ Ruby, and Lisp. Such systems are the engines of their own replacement, giving researchers and developers great power to experiment with, and explore future directions from within, their own small language kernels.},
location = {Tokyo, Japan}
}
@inproceedings{varv,
author = {Borowski, Marcel and Murray, Luke and Bagge, Rolf and Kristensen, Janus Bager and Satyanarayan, Arvind and Klokmose, Clemens Nylandsted},
title = {Varv: Reprogrammable Interactive Software as a Declarative Data Structure},
year = {2022},
isbn = {9781450391573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3491102.3502064},
doi = {10.1145/3491102.3502064},
abstract = {Most modern applications are immutable and turn-key despite the acknowledged benefits of empowering users to modify their software. Writing extensible software remains challenging, even for expert programmers. Reprogramming or extending existing software is often laborious or wholly blocked, requiring sophisticated knowledge of application architecture or setting up a development environment. We present Varv, a programming model representing reprogrammable interactive software as a declarative data structure. Varv defines interactive applications as a set of concepts that consist of a schema and actions. Applications in Varv support incremental modification, allowing users to reprogram through addition and selectively suppress, modify, or add behavior. Users can define high-level concepts, creating an abstraction layer and effectively a domain-specific language for their application domain, emphasizing reuse and modification. We demonstrate the reprogramming and collaboration capabilities of Varv in two case studies and illustrate how the event engine allows for extensive tooling support.},
booktitle = {Proceedings of the 2022 CHI Conference on Human Factors in Computing Systems},
articleno = {492},
numpages = {20},
keywords = {reprogramming, real-time collaboration, interactive software, liveness, declarative programming},
location = {New Orleans, LA, USA},
series = {CHI '22}
}
@unpublished{tds,
    author = {Joel Jakubovic and Tomas Petricek and Jonathan Edwards},
    title = "Technical Dimensions of Programming Systems (forthcoming)",
    year = 2022
}
@inproceedings{plrev,
author = {Gabriel, Richard P.},
title = {The Structure of a Programming Language Revolution},
year = {2012},
isbn = {9781450315623},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2384592.2384611},
doi = {10.1145/2384592.2384611},
abstract = {Engineering often precedes science. Incommensurability is real.},
booktitle = {Proceedings of the ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software},
pages = {195–214},
numpages = {20},
keywords = {science, incommensurability, engineering, paradigms},
location = {Tucson, Arizona, USA},
series = {Onward! 2012}
}
@inproceedings{mu,
author = {Agaram, Kartik},
title = {Bicycles for the Mind Have to Be See-Through},
year = {2020},
isbn = {9781450375078},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3397537.3397547},
doi = {10.1145/3397537.3397547},
abstract = {This paper describes ongoing research on building software to be comprehensible to its users so that they can tailor it to their needs in the field. Our test-bed is a computing stack called Mu that deemphasizes a clean interface in favor of a few global implementation properties: small implementation size, few distinct notations, parsimonious dependencies, a simple dependency graph that avoids cycles, and early warning on breaking changes. Assuming a 32-bit x86 processor and (for now) a basic third-party Unix-like kernel, Mu builds up from raw machine code to a memory-safe but less expressive language than C. Our approach to keeping software comprehensible is to reduce information hiding and abstraction, and instead encourage curiosity about internals. Our hypothesis is that abstractions help insiders who understand a project but hinder newcomers who understand only that project's domain. Where recent efforts to create "bicycles for the mind" have tended to focus on reducing learning time and effort, we explore organizing the curriculum to be incrementally useful, providing an hour of actionable value for an hour (or three) of study. The hope is that rewarding curiosity will stimulate curiosity in a virtuous cycle, so that more people are motivated to study and reflect on the difference between good vs bad design and good vs bad architecture, even as the study takes place over a lifetime of specialization in other domains. Spreading expertise in design is essential to the creation of a better society of more empowered citizens. Software tools have a role to play in this process, both by exemplifying good design and by providing visceral illustrations of the consequences of design choices.},
booktitle = {Conference Companion of the 4th International Conference on Art, Science, and Engineering of Programming},
pages = {173–186},
numpages = {14},
keywords = {software literacy},
location = {Porto, Portugal},
series = {<Programming> '20}
}
@online{masp,
  title = "Masp Brainstorming",
  url = {https://wiki.c2.com/?MaspBrainstorming},
  author = "C2 Wiki",
  year = "2014",
}
@online{gezira,
  title = "Gezira",
  url = {https://github.com/damelang/gezira},
  author = "Dan Amelang",
  year = "2012",
}
@online{nile,
  title = "Nile",
  url = {https://github.com/damelang/nile},
  author = "Dan Amelang",
  year = "2012",
}
@article{hazel,
author = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A.},
title = {Live Functional Programming with Typed Holes},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
url = {https://doi.org/10.1145/3290327},
doi = {10.1145/3290327},
abstract = {Live programming environments aim to provide programmers (and sometimes audiences) with continuous feedback about a program's dynamic behavior as it is being edited. The problem is that programming languages typically assign dynamic meaning only to programs that are complete, i.e. syntactically well-formed and free of type errors. Consequently, live feedback presented to the programmer exhibits temporal or perceptive gaps. This paper confronts this "gap problem" from type-theoretic first principles by developing a dynamic semantics for incomplete functional programs, starting from the static semantics for incomplete functional programs developed in recent work on Hazelnut. We model incomplete functional programs as expressions with holes, with empty holes standing for missing expressions or types, and non-empty holes operating as membranes around static and dynamic type inconsistencies. Rather than aborting when evaluation encounters any of these holes as in some existing systems, evaluation proceeds around holes, tracking the closure around each hole instance as it flows through the remainder of the program. Editor services can use the information in these hole closures to help the programmer develop and confirm their mental model of the behavior of the complete portions of the program as they decide how to fill the remaining holes. Hole closures also enable a fill-and-resume operation that avoids the need to restart evaluation after edits that amount to hole filling. Formally, the semantics borrows machinery from both gradual type theory (which supplies the basis for handling unfilled type holes) and contextual modal type theory (which supplies a logical basis for hole closures), combining these and developing additional machinery necessary to continue evaluation past holes while maintaining type safety. We have mechanized the metatheory of the core calculus, called Hazelnut Live, using the Agda proof assistant. We have also implemented these ideas into the Hazel programming environment. The implementation inserts holes automatically, following the Hazelnut edit action calculus, to guarantee that every editor state has some (possibly incomplete) type. Taken together with this paper's type safety property, the result is a proof-of-concept live programming environment where rich dynamic feedback is truly available without gaps, i.e. for every reachable editor state.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {14},
numpages = {32},
keywords = {typed holes, live programming, contextual modal type theory, structured editing, gradual typing}
}
@inproceedings{comprev,
author = {Kay, Alan C.},
title = {The Computer Revolution Hasn't Happened yet (Keynote Session)},
year = {2000},
isbn = {1581131984},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/354384.354390},
doi = {10.1145/354384.354390},
abstract = {The printing press was invented in the middle of the 15th century, yet it took 100 years before a book was considered dangerous enough to be banned. 150 years before science was invented, almost 200 years before a new kind of political essay was invented, and more than 300 hundred years before a country with an invented political system (the US) could be argued into existence via the press and a citizenry that could understand the arguments. Schooling and general literacy were also fruits of the press, and also took many centuries to become established. The commercial computer is now about 50 years old and is still imitating the paper culture that came before it, just as the printing press did with the manuscript culture it gradually replaced. No media revolution can be said to have happened without a general establishment of “literacy”: fluent “reading” and “writing” at the highest level of ideas that the medium can represent. With computers, we are so far from that fluent literacy — or even understanding what that literacy should resemble — that we could claim that the computer revolution hasn't even started. This talk will try to put a shape to the real computer revolution to come.},
booktitle = {Proceedings of the Eighth ACM International Conference on Multimedia},
pages = {1},
location = {Marina del Rey, California, USA},
series = {MULTIMEDIA '00}
}
@unpublished{dynpat,
title= {Design patterns in dynamic programming},
author = {Peter Norvig},
year = {1996},
note = {Object World, Boston, MA},
URL = {https://norvig.com/design-patterns/},
}
